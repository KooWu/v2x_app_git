#!/usr/bin/env python3

import os
import sys
import copy

from pycrate_asn1c.utils   import *
from pycrate_asn1c.glob    import *
from pycrate_asn1c.setobj  import *
from pycrate_asn1c.refobj  import *
from pycrate_asn1c.asnobj  import get_asnobj, ASN1Obj, INT, OID
from pycrate_asn1c.asnproc import compile_text

#
# License
#

LICENSE_MSG = '#\n\
# Copyright 2019 Steve Kwon <steve@libv2x.org>\n\
#\n\
# Licensed under the Apache License, Version 2.0 (the "License");\n\
# you may not use this file except in compliance with the License.\n\
# You may obtain a copy of the License at\n\
#\n\
#     http://www.apache.org/licenses/LICENSE-2.0\n\
#\n\
# Unless required by applicable law or agreed to in writing, software\n\
# distributed under the License is distributed on an "AS IS" BASIS,\n\
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\
# See the License for the specific language governing permissions and\n\
# limitations under the License.\n\
\n\
# This file is generated by libv2x, ros2gen.py\n\
\n\
# CAUTION: This file can be under the license of input ASN.1 file.\n\
#          The use of this file is your own responsibility.\n\
\n'

LICENSE_IMP = '/*\n\
 * Copyright 2019 Steve Kwon <steve@libv2x.org>\n\
 *\n\
 * Licensed under the Apache License, Version 2.0 (the "License");\n\
 * you may not use this file except in compliance with the License.\n\
 * You may obtain a copy of the License at\n\
 *\n\
 *     http://www.apache.org/licenses/LICENSE-2.0\n\
 *\n\
 * Unless required by applicable law or agreed to in writing, software\n\
 * distributed under the License is distributed on an "AS IS" BASIS,\n\
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\
 * See the License for the specific language governing permissions and\n\
 * limitations under the License.\n\
 */\n\
\n\
/* This file is generated by libv2x, ros2gen.py */\n\
\n\
/*\n\
 * CAUTION: This file can be under the license of input ASN.1 file.\n\
 *          The use of this file is your own responsibility.\n\
 */\n\
\n'

#
def change_name(name):
  new_name = ''
  prev = 0 # lower
  for i in range(0, len(name)):
    if (name[i] == '-'):
      new_name += '_'
      prev = 1 # _
    elif (name[i].isupper()):
      if i > 0 and prev == 0: new_name += '_'
      new_name += name[i].lower()
      prev = 2 # upper
    else:
      new_name += name[i].lower()
      prev = 0
  # C/C++ keywords
  if (new_name == 'long'):
    new_name = 'lon'
  elif (new_name == 'class'):
    new_name = 'cls'
  return new_name

#
def int_range_to_type_str(Obj):
  mm = [int(x) for x in Obj._const[0]['text'].split('..')]
  if mm[0] < 0:
    if mm[0] > -129 and mm[1] < 128: return 'int8'
    elif mm[0] > -32769 and mm[1] < 32768: return 'int16'
    elif mm[0] > -2147483649 and mm[1] < 2147483648: return 'int32'
    else: return 'int64'
  else:
    if mm[1] < 256: return 'uint8'
    elif mm[1] < 65536: return 'uint16'
    elif mm[1] < 4294967296: return 'uint32'
    else: return 'uint64'
#
def enum_range_to_type_str(Obj):
  mx = list(Obj._cont.values())[-1]
  if mx < 256: return 'uint8'
  elif mx < 65536: return 'uint16'
  elif mx < 4294967296: return 'uint32'
  else: return 'uint64'
#
def bit_str_range_to_type(Obj):
  mx = list(Obj._cont.values())[-1]
  if mx < 8: return ('uint8', 2) 
  elif mx < 16: return ('uint16', 4)
  elif mx < 32: return ('uint32', 8)
  elif mx < 64: return ('uint64', 16)
  else:
    print('BIT_STR NOT FOUND', Obj._name)
    # print(Obj.get_internals())
    sys.exit(1)

#
def gen_msg_bool(Obj, fd, vname):
  if Obj._const:
    print('BOOL NOT FOUND', Obj._name)
    # print(Obj.get_internals())
    sys.exit(1)
  else:
    fd.write('uint8 ' + vname + '\n')
#
def gen_msg_int(Obj, fd, vname):
  if Obj._typeref and isinstance(Obj._typeref, ASN1RefType):
    if isinstance(Obj._typeref.called, tuple):
      fd.write(Obj._typeref.called[1].replace('-', ''))
    else:
      fd.write(Obj._typeref.called.replace('-', ''))
    fd.write(' ' + vname + '\n')
  elif Obj._const[0]['type'] == 'VAL':
    fd.write(int_range_to_type_str(Obj) + ' ' + vname)
    fd.write(' # ' + Obj._const[0]['text'] + '\n')
  else:
    print('INT NOT FOUND', Obj._name)
    # print(Obj.get_internals())
    sys.exit(1)
#
def gen_msg_enum(Obj, fd, vname):
  fd.write(enum_range_to_type_str(Obj) + ' ' + vname + '\n')
  for k in Obj._cont:
    fd.write(enum_range_to_type_str(Obj))
    fd.write(' ' + change_name(k).upper() + '=' + str(Obj._cont[k]))
    fd.write(' # ' + k + '\n')
#
def gen_msg_bit_str(Obj, fd, vname):
  bt = bit_str_range_to_type(Obj)
  fd.write(bt[0] + ' ' + vname + '\n')
  for k in Obj._cont:
    fd.write(bt[0] + ' ' + change_name(k).upper() + '=' + str(Obj._cont[k]))
    fd.write(' # ' + k + '=0x%0*X' % (bt[1], (1 << Obj._cont[k])) + '\n')
#
def gen_msg_oct_str(Obj, fd, vname):
  if Obj._const[0]['type'] == 'SIZE':
    mm = Obj._const[0]['text'].replace('SIZE', '')
    mm = mm.replace('(', '').replace(')', '').strip().split('..')
    if len(mm) < 2: fd.write('uint8' + '[' + mm[0] + '] ' + vname)
    else: fd.write('uint8' + '[<=' + mm[1] + '] ' + vname)
    fd.write(' # ' + Obj._const[0]['text'] + '\n')
  else:
    print('OCT_STR NOT FOUND', Obj._name)
    # print(Obj.get_internals())
    sys.exit(1)
#
def gen_msg_str_ia5(Obj, fd, vname):
  if Obj._const[0]['type'] == 'SIZE':
    mm = Obj._const[0]['text'].replace('SIZE', '')
    mm = mm.replace('(', '').replace(')', '').strip().split('..')
    if len(mm) < 2: fd.write('int8' + '[' + mm[0] + '] ' + vname)
    else: fd.write('int8' + '[<=' + mm[1] + '] ' + vname)
    fd.write(' # ' + Obj._const[0]['text'] + '\n')
  else:
    print('STR_IA5 NOT FOUND', Obj._name)
    # print(Obj.get_internals())
    sys.exit(1)
#
def gen_msg_choice(Obj, fd, vname):
  for k in Obj._cont:
    tr = Obj._cont[k]._typeref;
    if isinstance(tr, ASN1RefType):
      if isinstance(tr.called, tuple): fd.write(tr.called[1].replace('-', ''))
      else: fd.write(tr.called.replace('-', ''))
      fd.write('[<=1] ' + change_name(k) + '\n')
    else:
      obj = Obj._cont[k]
      if obj._type == TYPE_SEQ_OF:
        gen_msg_seq_of(obj, fd, k, False)
      else:
        print('CHOICE NOT FOUND', Obj._name, obj._name, obj._type)
        # print(Obj.get_internals())
        sys.exit(1)
#
def gen_msg_seq_of(Obj, fd, vname, opt):
  tr  = Obj._cont._typeref;
  if isinstance(tr, ASN1RefType):
    if isinstance(tr.called, tuple): fd.write(tr.called[1].replace('-', ''))
    else: fd.write(tr.called.replace('-', ''))
    if Obj._const and Obj._const[0]['type'] == 'SIZE':
      mm = Obj._const[0]['text'].replace('SIZE', '')
      mm = mm.replace('(', '').replace(')', '').strip().split('..')
      if len(mm) < 2: fd.write('[' + mm[0] + '] ' + vname)
      else: fd.write('[<=' + mm[1] + '] ' + vname)
      fd.write(' # ' + Obj._const[0]['text'] + '\n')
    else:
      if opt: fd.write('[<=1] ' + vname + '\n')
      else: fd.write('[] ' + vname + '\n')
  else:
    print('SEQ OF NOT FOUND', Obj._name)
    # print(Obj.get_internals())
    sys.exit(1)
#
def gen_msg_seq(Obj, fd, vname, asnfile, mod_path, mod_name):
  #
  pcnt = 0
  pidx = 0
  for k in Obj._cont:
    tr = Obj._cont[k]._typeref;
    if isinstance(tr, ASN1RefType): pass
    elif isinstance(tr, ASN1RefClassField): pass
    elif Obj._cont[k]._type in (TYPE_BOOL, TYPE_INT, TYPE_ENUM, TYPE_BIT_STR, TYPE_OCT_STR, TYPE_STR_IA5):
      pcnt += 1
  #
  for k in Obj._cont:
    tr = Obj._cont[k]._typeref;
    if isinstance(tr, ASN1RefType):
      if isinstance(tr.called, tuple): fd.write(tr.called[1].replace('-', ''))
      else: fd.write(tr.called.replace('-', ''))
      if k in Obj._root_opt: fd.write('[<=1]')
      fd.write(' ' + change_name(k) + '\n')
    elif isinstance(tr, ASN1RefClassField):
      obj = Obj._cont[k]
      if obj._type == TYPE_INT:
        if isinstance(obj._typeref.called, tuple):
          cObj = GLOBAL.MOD[mod_name][obj._typeref.called[1]]
        else:
          cObj = GLOBAL.MOD[mod_name][obj._typeref.called]
        if isinstance(cObj._cont['id']._typeref, ASN1RefType):
          if isinstance(cObj._cont['id']._typeref.called, tuple):
            fd.write(cObj._cont['id']._typeref.called[1].replace('-', ''))
          else:
            fd.write(cObj._cont['id']._typeref.called.replace('-', ''))
          fd.write(' ' + change_name(k) + '\n')
        else:
          print('SEQ INT NOT FOUND', Obj._name, obj._name, obj._type)
          # print(Obj.get_internals())
          sys.exit(1)
      elif obj._type == TYPE_OPEN:
        for o in obj._const[0]['tab']._val['root']:
          oi = o['id']
          ot = o['Type']
          if isinstance(ot._typeref, ASN1RefType):
            if isinstance(ot._typeref.called, tuple):
              called = ot._typeref.called[1].replace('-', '')
            else:
              called = ot._typeref.called.replace('-', '')
            fd.write(called + '[<=1] ' + change_name(called))
            fd.write(' # id=' + str(oi) + '\n')
          else:
            print('SEQ OPEN NOT FOUND', Obj._name, obj._name, obj._type)
            # print(Obj.get_internals())
            sys.exit(1)
      else:
        print('SEQ CLASS NOT FOUND', Obj._name, obj._name, obj._type)
        # print(Obj.get_internals())
        sys.exit(1)
    else:
      obj = Obj._cont[k]
      #
      if pcnt > 1: pstr = str(pidx)
      else: pstr = ''
      if obj._type in (TYPE_BOOL, TYPE_INT, TYPE_ENUM, TYPE_BIT_STR, TYPE_OCT_STR, TYPE_STR_IA5):
        pidx += 1
      #
      if   obj._type == TYPE_BOOL   : gen_msg_bool(obj, fd, vname + pstr)
      elif obj._type == TYPE_INT    : gen_msg_int(obj, fd, vname + pstr)
      elif obj._type == TYPE_ENUM   : gen_msg_enum(obj, fd, vname + pstr)
      elif obj._type == TYPE_BIT_STR: gen_msg_bit_str(obj, fd, vname + pstr)
      elif obj._type == TYPE_OCT_STR: gen_msg_oct_str(obj, fd, vname + pstr)
      elif obj._type == TYPE_STR_IA5: gen_msg_str_ia5(obj, fd, vname + pstr)
      elif obj._type == TYPE_CHOICE:
        mname = (Obj._name + obj._name[0].upper() + obj._name[1:]).replace('-', '')
        path = os.path.join(mod_path, mname + '.msg')
        ofd = open(path, 'w')
        ofd.write(LICENSE_MSG)
        ofd.write('# From ' + asnfile + ', ' + mod_name)
        ofd.write(', ' + Obj._name + '.' + obj._name)
        ofd.write(', ' + obj._type + '\n\n')
        gen_msg_choice(obj, ofd, vname)
        ofd.close()
        #
        fd.write(mname)
        if k in Obj._root_opt: fd.write('[<=1]')
        fd.write(' ' + change_name(k) + ' # anonymous type\n')
      elif obj._type == TYPE_SEQ_OF :
        gen_msg_seq_of(obj, fd, k, k in Obj._root_opt)
      elif obj._type == TYPE_SEQ:
        mname = (Obj._name + obj._name[0].upper() + obj._name[1:]).replace('-', '')
        path = os.path.join(mod_path, mname + '.msg')
        ofd = open(path, 'w')
        ofd.write(LICENSE_MSG)
        ofd.write('# From ' + asnfile + ', ' + mod_name)
        ofd.write(', ' + Obj._name + '.' + obj._name)
        ofd.write(', ' + obj._type + '\n\n')
        gen_msg_seq(obj, ofd, vname, asnfile, mod_path, mod_name)
        ofd.close()
        #
        fd.write(mname)
        if k in Obj._root_opt: fd.write('[<=1]')
        fd.write(' ' + change_name(k) + ' # anonymous type\n')
      else:
        print('SEQ NOT FOUND', Obj._name, obj._name, obj._type)
        # print(Obj.get_internals())
        sys.exit(1)
#
def gen_msg(asnfile, outpath, vname):
  for mod_name in GLOBAL.MOD:
    if mod_name[0] == '_': continue
    mod_path = os.path.join(outpath, mod_name)
    if not os.path.exists(mod_path):
      os.mkdir(mod_path)
    #
    Mod = GLOBAL.MOD[mod_name]
    obj_names = [obj_name for obj_name in Mod.keys() if obj_name[0:1] != '_']
    #
    for obj_name in obj_names:
      Obj = Mod[obj_name]
      if Obj._mode != MODE_TYPE: continue
      if Obj._type == TYPE_CLASS: continue
      # print(mod_name, Obj._name, Obj._mode, Obj._type, Obj._typeref)
      path = os.path.join(mod_path, Obj._name.replace('-', '') + '.msg')
      fd = open(path, 'w')
      fd.write(LICENSE_MSG)
      fd.write('# From ' + asnfile + ', ' + mod_name + ', ' + obj_name)
      fd.write(', ' + Obj._type + '\n\n')
      #
      if   Obj._type == TYPE_BOOL   : gen_msg_bool(Obj, fd, vname)
      elif Obj._type == TYPE_INT    : gen_msg_int(Obj, fd, vname)
      elif Obj._type == TYPE_ENUM   : gen_msg_enum(Obj, fd, vname)
      elif Obj._type == TYPE_BIT_STR: gen_msg_bit_str(Obj, fd, vname)
      elif Obj._type == TYPE_OCT_STR: gen_msg_oct_str(Obj, fd, vname)
      elif Obj._type == TYPE_STR_IA5: gen_msg_str_ia5(Obj, fd, vname)
      elif Obj._type == TYPE_CHOICE : gen_msg_choice(Obj, fd, vname)
      elif Obj._type == TYPE_SEQ_OF :
        gen_msg_seq_of(Obj, fd, vname, False)
      elif Obj._type == TYPE_SEQ:
        gen_msg_seq(Obj, fd, vname, asnfile, mod_path, mod_name)
      else:
        print('TYPE NOT FOUND', Obj._name, Obj._type)
        # print(Obj.get_internals())
        sys.exit(1)
      #
      fd.close()
    #
    for obj_name in obj_names:
      Obj = Mod[obj_name]
      if Obj._mode != MODE_VALUE: continue
      # print(mod_name, Obj._name, Obj._mode, Obj._type, Obj._typeref)
      if Obj._type == TYPE_INT:
        if isinstance(Obj._typeref, ASN1RefType):
          if isinstance(Obj._typeref.called, tuple):
            path = os.path.join(mod_path, Obj._typeref.called[1].replace('-', '') + '.msg')
            pObj = Mod[Obj._typeref.called[1]]
          else:
            path = os.path.join(mod_path, Obj._typeref.called.replace('-', '') + '.msg')
            pObj = Mod[Obj._typeref.called]
          if os.path.exists(path) and pObj._const[0]['type'] == 'VAL':
            fd = open(path, 'a+')
            fd.write(int_range_to_type_str(pObj) + ' ')
            fd.write(change_name(Obj._name).upper() + '=' + str(Obj._val))
            fd.write(' # ' + Obj._name + '\n')
            fd.close()
          else:
            print('VALUE FILE NOT FOUND', Obj._name)
            # print(Obj.get_internals())
            sys.exit(1)
        else:
          print('VALUE REF NOT FOUND', Obj._name)
          # print(Obj.get_internals())
          sys.exit(1)
      else:
        print('VALUE NOT FOUND', Obj._name, Obj._type)
        # print(Obj.get_internals())
        sys.exit(1)

#
def check_dup():
  found = False
  for mod_name in GLOBAL.MOD:
    if mod_name[0] == '_': continue
    Mod = GLOBAL.MOD[mod_name]
    obj_names = [obj_name for obj_name in Mod.keys() if obj_name[0:1] != '_']
    for obj_name in obj_names:
      Obj = Mod[obj_name]
      if Obj._mode != MODE_TYPE: continue
      for mod_name2 in GLOBAL.MOD:
        if mod_name2[0] == '_': continue
        if mod_name == mod_name2: continue
        Mod2 = GLOBAL.MOD[mod_name2]
        obj_names2 = [obj_name for obj_name in Mod2.keys() if obj_name[0:1] != '_']
        if obj_name in obj_names2:
          print('DUPLICATED NAME FOUND', mod_name, mod_name2, obj_name)
          found = True
  if found:
    sys.exit(1)

#
def main(asnfile, outpath):
  #
  txt = []
  fd = open(asnfile)
  txt.append(fd.read())
  fd.close()
  #
  ckw = {}
  ckw['filenames'] = list([asnfile])
  compile_text(txt, **ckw)
  #
  if not os.path.exists(outpath):
    os.mkdir(outpath)
  #
  check_dup()
  gen_msg(asnfile, outpath, 'val')

#
if __name__ == '__main__':
  if len(sys.argv) < 3:
    print('usage:', sys.argv[0], 'asnfile.asn1 outpath')
  else:
    main(sys.argv[1], sys.argv[2])

